<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单元测试IllegalStateException问题]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95IllegalStateException%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[该文是解决IllegalState Failed to load ApplicationContext异常中的一种。 背景介绍 spring-web-4.3.6.RELEASE Junit v4.12 h2 v1.4.192 Run As单元测试类，全部测试用例可以通过 mvn test部分测试类下面所有的测试用例都报错 mvn test报错信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778testMethod(io.github.eericzeng.StudentTest) Time elapsed: 0 sec &lt;&lt;&lt; ERROR!java.lang.IllegalStateException: Failed to load ApplicationContext at org.h2.message.DbException.getJdbcSQLException(DbException.java:345) at org.h2.message.DbException.get(DbException.java:179) at org.h2.message.DbException.get(DbException.java:155) at org.h2.command.ddl.CreateTable.update(CreateTable.java:115) at org.h2.command.CommandContainer.update(CommandContainer.java:98) at org.h2.command.Command.executeUpdate(Command.java:258) at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:184) at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:158) at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:471) at org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.populate(ResourceDatabasePopulator.java:238) at org.springframework.jdbc.datasource.init.CompositeDatabasePopulator.populate(CompositeDatabasePopulator.java:87) at org.springframework.jdbc.datasource.init.DatabasePopulatorUtils.execute(DatabasePopulatorUtils.java:48) at org.springframework.jdbc.datasource.init.DataSourceInitializer.execute(DataSourceInitializer.java:108) at org.springframework.jdbc.datasource.init.DataSourceInitializer.afterPropertiesSet(DataSourceInitializer.java:93) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1687) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542) at org.springframework.test.context.web.AbstractGenericWebContextLoader.loadContext(AbstractGenericWebContextLoader.java:134) at org.springframework.test.context.web.AbstractGenericWebContextLoader.loadContext(AbstractGenericWebContextLoader.java:61) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:108) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:251) at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189) at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131) at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:228) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:287) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:289) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:247) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264) at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153) at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray2(ReflectionUtils.java:208) at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:158) at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:86) at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153) at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:95)Results :Tests in error: ? IllegalState Failed to load ApplicationContext 异常排查由异常信息getJdbcSQLException/ApplicationContext推断出配置信息有问题，而且是关于数据库的异常，getJdbcSQLException是h2抛出的，说明h2在初始化就存在问题。配置单元测试log4j日志，log4j日志关键信息如下： 1Caused by: org.h2.jdbc.JdbcSQLException: Table &quot;student&quot; already exists; SQL statement: 执行SQL创建数据表失败，说明建表语句被执行了多次。检查SQL脚本发现，脚本中只有创建数据表的语句，并没有DROP语句，所以每次执行测试用例时都会失败。 解决办法根据本次异常排查情况，在CREATE TABLE前添加如下SQL语句： 1DROP TABLE IF EXISTS 'student';]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>单元测试</tag>
        <tag>junit</tag>
        <tag>h2</tag>
        <tag>IllegalStateException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7服务开机自动启动]]></title>
    <url>%2F2019%2F09%2F07%2FCentOS7%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[专治健忘症 以Apache HTTP服务为例： 添加开机启动开机启动http服务 1systemctl enable httpd 添加手动安装的服务，如nginx，可参考该文。 删除开机启动删除开机启动http服务 1systemctl disable httpd 查看所有开机启动的服务1systemctl list-unit-files | grep enabled]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>笔记</tag>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanUtils拷贝Map、JSONObject中的枚举、POJO属性]]></title>
    <url>%2F2019%2F08%2F26%2FBeanUtils%E6%8B%B7%E8%B4%9DMap%E3%80%81JSONObject%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E3%80%81POJO%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[版本说明 commons-beanutils：1.9.3 fastjson：1.2.58 场景使用BeanUtils.copyProperties()拷贝Map/JSONObject时，无法正常拷贝属性类型为枚举或POJO。此时，需要使用ConvertUtils注册一个自定义的转换类。 实验实验准备: Student类（拷贝对象），Student中有三个属性name/sex/grade分别为String/enum/POJO类型（包含属性比较方法propertiesEquals()）； Sex类，枚举类型，定义了FEMAL/MALE； Grade类，简单对象，包含三个属性。 定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * 学生类，属性中有一个枚举类型、一个POJO。 * * @author zengguang * */public class Student &#123; /** * 姓名 */ private String name; /** * 性别，enum */ private Sex sex; /** * 成绩，POJO */ private Grade grade; public Student() &#123; &#125; public Student(String name, Sex sex, Grade grade) &#123; this.name = name; this.sex = sex; this.grade = grade; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Sex getSex() &#123; return sex; &#125; public void setSex(Sex sex) &#123; this.sex = sex; &#125; public Grade getGrade() &#123; return grade; &#125; public void setGrade(Grade grade) &#123; this.grade = grade; &#125;&#125;/** * 成绩。 * * @author zengguang * */public class Grade &#123; private Integer mathematics; private Integer chinese; private Integer english; public Grade() &#123; &#125; public Grade(Integer mathematics, Integer chinese, Integer english) &#123; super(); this.mathematics = mathematics; this.chinese = chinese; this.english = english; &#125; public Integer getMathematics() &#123; return mathematics; &#125; public void setMathematics(Integer mathematics) &#123; this.mathematics = mathematics; &#125; public Integer getChinese() &#123; return chinese; &#125; public void setChinese(Integer chinese) &#123; this.chinese = chinese; &#125; public Integer getEnglish() &#123; return english; &#125; public void setEnglish(Integer english) &#123; this.english = english; &#125;&#125;/** * 枚举类，性别。 * * @author zengguang * */public enum Sex &#123; MALE, FEMAL;&#125; 实验对比 Java对象之间的拷贝 BeanMap拷贝到Java对象 JSONObject对象拷贝到Java对象 HashMap对象拷贝到Java对象 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Grade g = new Grade(100, 99, 98);Student origBean = new Student("小明", Sex.MALE, g);Student destBean = new Student();// JavaBean → JavaBeantry &#123; BeanUtils.copyProperties(destBean, origBean);&#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace();&#125;validate(destBean, origBean, "JavaBean → JavaBean");// BeanMap → JavaBean BeanMap/BeanUtils同为beanutils包中的类BeanMap destBeanMap = new BeanMap(origBean);try &#123; BeanUtils.copyProperties(destBean, destBeanMap);&#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace();&#125;validate(destBeanMap, origBean, "BeanMap → JavaBean");// Map → JavaBeanString json = JSONObject.toJSONString(origBean);JSONObject obj = JSONObject.parseObject(json);ConvertUtils.register(new Converter() &#123; public &lt;T&gt; T convert(Class&lt;T&gt; clazz, Object value) &#123; // 应对json中枚举类型被转为字符串的问题 if (value instanceof String) &#123; return clazz.cast(Sex.valueOf((String) value)); &#125; return clazz.cast(value); &#125;&#125;, Sex.class);ConvertUtils.register(new Converter() &#123; public &lt;T&gt; T convert(Class&lt;T&gt; clazz, Object value) &#123; Grade g = new Grade(); try &#123; BeanUtils.copyProperties(g, value); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; return clazz.cast(g); &#125;&#125;, Grade.class);try &#123; BeanUtils.copyProperties(destBean, obj);&#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace();&#125;// 为方便比较，orig与dest反过来计算validate(obj, destBean, "JSONOjbect → JavaBean");Map&lt;?, ?&gt; m = JSONObject.toJavaObject(obj, Map.class);Map&lt;?, ?&gt; map = new HashMap&lt;&gt;(m);try &#123; BeanUtils.copyProperties(destBean, map);&#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace();&#125;validate(map, destBean, "HashMap → JavaBean"); 完整代码 github: https://github.com/eEricZeng/demo/tree/beanutils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299package io.github.eericzeng;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import org.apache.commons.beanutils.BeanMap;import org.apache.commons.beanutils.BeanUtils;import org.apache.commons.beanutils.ConvertUtils;import org.apache.commons.beanutils.Converter;import com.alibaba.fastjson.JSONObject;/** * 使用&#123;@link BeanUtils#copyProperties&#125;拷贝Map/Json中的Enum和POJO。 * * @author zengguang 2019年8月24日 * */public class BeanUtilsTest &#123; public static void main(String[] args) &#123; BeanUtilsTest beanUtilsTest = new BeanUtilsTest(); beanUtilsTest.copyProperties(); &#125; /** * 校验属性值是否相等。 * * @param dest * 拷贝目标对象 * @param orig * 拷贝源对象 * @param label * 标签 */ private void validate(Object dest, Student orig, String label) &#123; if (orig.propertiesEquals(dest)) &#123; System.out.println(label + ": properties copy success !"); &#125; else &#123; System.out.println(label + ": properties copy fail !"); &#125; &#125; /** * 正确的拷贝方法。 */ private void copyProperties() &#123; Grade g = new Grade(100, 99, 98); Student origBean = new Student("小明", Sex.MALE, g); Student destBean = new Student(); // JavaBean → JavaBean try &#123; BeanUtils.copyProperties(destBean, origBean); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; validate(destBean, origBean, "JavaBean → JavaBean"); // BeanMap → JavaBean BeanMap/BeanUtils同为beanutils包中的类 BeanMap destBeanMap = new BeanMap(origBean); try &#123; BeanUtils.copyProperties(destBean, destBeanMap); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; validate(destBeanMap, origBean, "BeanMap → JavaBean"); // Map → JavaBean String json = JSONObject.toJSONString(origBean); JSONObject obj = JSONObject.parseObject(json); ConvertUtils.register(new Converter() &#123; public &lt;T&gt; T convert(Class&lt;T&gt; clazz, Object value) &#123; // 应对json中枚举类型被转为字符串的问题 if (value instanceof String) &#123; return clazz.cast(Sex.valueOf((String) value)); &#125; return clazz.cast(value); &#125; &#125;, Sex.class); ConvertUtils.register(new Converter() &#123; public &lt;T&gt; T convert(Class&lt;T&gt; clazz, Object value) &#123; Grade g = new Grade(); try &#123; BeanUtils.copyProperties(g, value); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; return clazz.cast(g); &#125; &#125;, Grade.class); try &#123; BeanUtils.copyProperties(destBean, obj); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; // 为方便比较，orig与dest反过来计算 validate(obj, destBean, "JSONOjbect → JavaBean"); Map&lt;?, ?&gt; m = JSONObject.toJavaObject(obj, Map.class); Map&lt;?, ?&gt; map = new HashMap&lt;&gt;(m); try &#123; BeanUtils.copyProperties(destBean, map); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; validate(map, destBean, "HashMap → JavaBean"); &#125; /** * 学生类，属性中有一个枚举类型、一个POJO。 * * @author zengguang * */ public class Student &#123; /** * 姓名 */ private String name; /** * 性别，enum */ private Sex sex; /** * 成绩，POJO */ private Grade grade; public Student() &#123; &#125; public Student(String name, Sex sex, Grade grade) &#123; this.name = name; this.sex = sex; this.grade = grade; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Sex getSex() &#123; return sex; &#125; public void setSex(Sex sex) &#123; this.sex = sex; &#125; public Grade getGrade() &#123; return grade; &#125; public void setGrade(Grade grade) &#123; this.grade = grade; &#125; public boolean propertiesEquals(Object o) &#123; if (this == o) return true; if (null == o) return false; if (o instanceof Student) &#123; Student s = (Student) o; if (!this.name.equals(s.name)) return false; if (!this.sex.equals(s.sex)) return false; if (!this.grade.propertiesEquals(s.grade)) return false; return true; &#125; else if (o instanceof Map) &#123; Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;) o; if (!this.name.equals(m.get("name"))) return false; Object obj = m.get("sex"); Sex s = m.get("sex") instanceof String ? Sex.valueOf((String) obj) : (Sex) obj; if (!this.sex.equals(s)) return false; if (!this.grade.propertiesEquals(m.get("grade"))) return false; return true; &#125; return false; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", sex=" + sex + ", grade=" + grade + "]"; &#125; &#125; /** * 成绩。 * * @author zengguang * */ public class Grade &#123; private Integer mathematics; private Integer chinese; private Integer english; public Grade() &#123; &#125; public Grade(Integer mathematics, Integer chinese, Integer english) &#123; super(); this.mathematics = mathematics; this.chinese = chinese; this.english = english; &#125; public Integer getMathematics() &#123; return mathematics; &#125; public void setMathematics(Integer mathematics) &#123; this.mathematics = mathematics; &#125; public Integer getChinese() &#123; return chinese; &#125; public void setChinese(Integer chinese) &#123; this.chinese = chinese; &#125; public Integer getEnglish() &#123; return english; &#125; public void setEnglish(Integer english) &#123; this.english = english; &#125; public boolean propertiesEquals(Object o) &#123; if (this == o) return true; if (null == o) return false; if (o instanceof Grade) &#123; Grade g = (Grade) o; if (!this.mathematics.equals(g.mathematics)) return false; if (!this.chinese.equals(g.chinese)) return false; if (!this.english.equals(g.english)) return false; return true; &#125; else if (o instanceof Map) &#123; Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;) o; if (null == m.get("mathematics")) return false; if (null == m.get("chinese")) return false; if (null == m.get("english")) return false; Object om = m.get("mathematics") instanceof String ? Integer.valueOf((String) m.get("mathematics")) : m.get("mathematics"); Object oc = m.get("chinese") instanceof String ? Integer.valueOf((String) m.get("chinese")) : m.get("chinese"); Object oe = m.get("english") instanceof String ? Integer.valueOf((String) m.get("english")) : m.get("english"); if (!this.mathematics.equals(om)) return false; if (!this.chinese.equals(oc)) return false; if (!this.english.equals(oe)) return false; return true; &#125; return false; &#125; @Override public String toString() &#123; return "Grade [mathematics=" + mathematics + ", chinese=" + chinese + ", english=" + english + "]"; &#125; &#125; /** * 枚举类，性别。 * * @author zengguang * */ public enum Sex &#123; MALE, FEMAL; &#125;&#125; 题外话BeanUtils性能堪忧，可参考某大佬写的对比博客，见参考资料。 参考资料 BeanCopy类库]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>beanutils</tag>
        <tag>copyProperties</tag>
        <tag>ClassCastException</tag>
        <tag>拷贝属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带资源的try语句]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%B8%A6%E8%B5%84%E6%BA%90%E7%9A%84try%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[语法带资源的try语句，英文try-with-resources，JDK1.7及之后有效： 12345try(/** * 实现了java.io.Closeable接口的资源定义。 */) &#123; // 业务代码&#125; 示例： 12345try (BufferedReader br = new BufferedReader(new FileReader("text.txt")))&#123; // 业务代码&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 与不带资源try的对比如果只有一个资源使用try-with-resources并无太大优势，try/catch/finally则更简洁一点。但是当多个资源同时打开时，就方便太多了，对比如下： try-with-resources 123456try (BufferedReader br1 = new BufferedReader(new FileReader("text1.txt")); BufferedReader br2 = new BufferedReader(new FileReader("text2.txt"))) &#123; // 业务代码&#125; catch (IOException e) &#123; e.printStackTrace();&#125; JDK1.7之前 12345678910111213141516171819202122232425BufferedReader br1 = null;BufferedReader br2 = null;try &#123; br1 = new BufferedReader(new FileReader("text1.txt")); br2 = new BufferedReader(new FileReader("text2.txt")); // 业务代码&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (null != br1) &#123; br1.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != br2) &#123; br2.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：JDK1.7之前正确关闭的资源是finally和try互相嵌套才能正确关闭，下面这种是错误的： 12345678910111213141516171819BufferedReader br1 = null;BufferedReader br2 = null;try &#123; br1 = new BufferedReader(new FileReader("text1.txt")); br2 = new BufferedReader(new FileReader("text2.txt"));&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (null != br1) &#123; br1.close(); // br1执行close()出现异常，br2就无法关闭了 &#125; if (null != br2) &#123; br2.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 常见异常之前开发时经常出现一个异常提示如下： 1java.io.IOException: 您的主机中的软件中止了一个已建立的连接 后来发现调用的框架工具中未正确关闭资源，导致连续请求时触发该异常。 参考资料 The Java™ Tutorials]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>try</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDE远程调试]]></title>
    <url>%2F2019%2F08%2F21%2F%E4%BD%BF%E7%94%A8IDE%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[以被调试jar包项目为例，使用IDEA/Eclipse对jar包进行远程调试。 IDEA 版本：IntelliJ IDEA 2019.1.2 (Ultimate Edition) 启动被调试jar包时使用如下命令： 1java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar XXX.jar 其中XXX.jar是被调试项目的jar包。打开IDEA，依次点击Run-&gt;Debug Configurations，点击Run/Debug Configurations对话框左上角的“+”号，选择Remote。根据需要修改Host和module如下图所示： 保存配置之后，点击Debug即可。 Eclipse 版本：Eclipse Oxygen 2.2.100.v20170612-0950 启动时使用如下命令： 1java -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 -jar XXX.jar 打开Eclipse，依次点击Run-&gt;Debug Configurations，鼠标右击Remote Java Application-&gt;New。如下图所示，表单必填项有Connect中的Project和Host，其余的Name、Port根据需要进行修改，端口号与被调试项目一致即可。 启动Debug运行刚刚创建的“Remote Debug”即可。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发工具</tag>
        <tag>eclipse</tag>
        <tag>IDEA</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson自带JsonPath与json-path比较]]></title>
    <url>%2F2019%2F08%2F07%2Ffastjson%E8%87%AA%E5%B8%A6JsonPath%E4%B8%8Ejson-path%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[场景fastjson从1.2版本开始支持JsonPath语法，但是在部分情境下还是无法很好的支持。例如下面的json结构： 123456789101112131415161718192021222324252627&#123; "store": &#123; "book": [&#123; "title": "Java虚拟机", "price": 20 &#125;, &#123; "title": "Head First 设计模式", "price": 72 &#125;, &#123; "title": "重构：改善既有代码的设计", "isbn": "123", "price": 38 &#125;, &#123; "title": "Spring实践4", "isbn": "321", "price": 32 &#125;, &#123; "title": "图解HTTP", "isbn": "543", "price": 25 &#125;], "bicycle": &#123; "color": "red", "price": 219 &#125; &#125;&#125; 需要取出book中的title和price字段，理想情况是这样的： 12345678910111213141516[&#123; "title": "Java虚拟机", "price": 20&#125;, &#123; "title": "Head First 设计模式", "price": 72&#125;, &#123; "title": "重构：改善既有代码的设计", "price": 38&#125;, &#123; "title": "Spring实践4", "price": 32&#125;, &#123; "title": "图解HTTP", "price": 25&#125;] 测试引入fastjson/json-path版本如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt;&lt;/dependency&gt; java代码： 123456789101112131415161718import com.alibaba.fastjson.JSONPath;import com.jayway.jsonpath.JsonPath;public class JsonPathTest &#123; public static void main(String[] args) &#123; String json = "&#123;\"store\": &#123;\"book\": [&#123;\"title\": \"Java虚拟机\",\"price\": 20&#125;, &#123;\"title\": \"Head First 设计模式\",\"price\": 72&#125;, &#123;\"title\": \"重构：改善既有代码的设计\",\"isbn\": \"123\",\"price\": 38&#125;, &#123;\"title\": \"Spring实践4\",\"isbn\": \"321\",\"price\": 32&#125;, &#123;\"title\": \"图解HTTP\",\"isbn\": \"543\",\"price\": 25&#125;],\"bicycle\": &#123;\"color\": \"red\",\"price\": 219&#125;&#125;&#125;"; String jsonPath = "$['store']['book'][:-1]['price','title']"; Object obj = JSONPath.read(json, jsonPath); System.out.println(obj); jsonPath = "$.store.book.[*].['title', 'price']"; obj = JsonPath.parse(json).read(jsonPath); String str = JSONObject.toJSONString(obj); System.out.println(str); &#125;&#125; 测试结果： [[20,72,38,32,25], [&quot;Java虚拟机&quot;,&quot;Head First 设计模式&quot;,&quot;重构：改善既有代码的设计&quot;,&quot;Spring实践4&quot;,&quot;图解HTTP&quot;]] [{&quot;title&quot;:&quot;Java虚拟机&quot;,&quot;price&quot;:20},{&quot;title&quot;:&quot;Head First 设计模式&quot;,&quot;price&quot;:72},{&quot;title&quot;:&quot;重构：改善既有代码的设计&quot;,&quot;price&quot;:38},{&quot;title&quot;:&quot;Spring实践4&quot;,&quot;price&quot;:32},{&quot;title&quot;:&quot;图解HTTP&quot;,&quot;price&quot;:25}]从结果上看json-path可以实现json带list结构的结果筛选，而fastjson只提取了两个列表（也可能我的语法不对，但是以目前的版本，我查了很多资料都没有找到一个更好的语法实现，如果有请联系我）。 参考资料 fastjson对JSONPath的官方教程 Jayway JsonPath GitRepo]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>fastjson</tag>
        <tag>jsonpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J-IM启动]]></title>
    <url>%2F2019%2F08%2F05%2FJ-IM%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[开源社区：Gitee 下载J-IM源码，目前（2019.8.1）最新版本（v2.6.0)的J-IM没有上传到Maven仓库中，需要自己打包。作为一个Java开发人员，我相信你本地安装了Maven而且配置了环境变量。下载源码后进入jim-parent文件夹执行如下命令： 12mvn clean package -U -Dmaven.test.skip=true# Maven命令解释: 打包并跳过测试类的编译 或者直接双击jim-parent/install.bat，该脚本实际执行如下命令： 12call mvn clean install# 该命令会将打好的包存放到本地Maven仓库里，请悉知 J-IM提供了简单的client/server端演示Demo，当然本文主要关心的是服务端如何启动。该Demo项目名为jim-server-demo，进入该项目的target目录找到刚刚打好的jar包，如：jim-server-demo-2.6.0v20190114-RELEASE.jar。 启动jar包启动的通常做法是执行如下命令： 1java -jar jim-server-demo-2.6.0v20190114-RELEASE.jar 但是执行后会报如下异常： 1jim-server-demo-2.6.0.v20190114-RELEASE.jar中没有主清单属性 打开jar包里的META-INF/MANIFEST.MF文件会发现缺失启动类。解决办法是在pom里添加插件： jar/dependency插件配置如下： 12345678910111213141516171819202122232425262728293031&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;mainClass&gt;org.jim.server.demo.ImServerDemoStart&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.10&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 再次启动就可以啦： 1java -jar jim-server-demo-2.6.0.v20190114-RELEASE.jar 这样使用有个限制，拷贝jar包时需要带lib文件夹。 assembly插件配置如下： 1234567891011121314151617181920212223&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;org.jim.server.demo.ImServerDemoStart&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;!--下面是为了使用 mvn package命令，如果不加则使用mvn assembly--&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assemble&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; mvn打包后生成jim-server-demo-2.6.0.v20190114-RELEASE.jar和jim-server-demo-2.6.0.v20190114-RELEASE-jar-with-dependencies.jar两个jar包，后面那个包将依赖的jar一起打包，任何位置直接使用java -jar即可。 IDE启动直接启动main方法。 SpringBoot集成J-IM启动类继承org.springframework.boot.CommandLineRunner接口，实现run()方法: 1234567public class JimStarter implements CommandLineRunner &#123; @Override public void run(String... args) &#123; // J-IM启动代码 &#125;&#125; 参考资料 jar包中META-INF文件作用 java -cp &amp; java jar的区别]]></content>
      <categories>
        <category>即时通讯</category>
      </categories>
      <tags>
        <tag>即时通讯</tag>
        <tag>IM</tag>
        <tag>J-IM</tag>
        <tag>t-io</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse查看jar包源码]]></title>
    <url>%2F2019%2F07%2F31%2FEclipse%E6%9F%A5%E7%9C%8Bjar%E5%8C%85%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[还在使用Eclipse的同学真是伤不起，点开一个未知类报一个Source not fournd。两步完全解决查看jar源码的问题。 Maven配置如图，打开Window-&gt;Preferences-&gt;Maven，勾选“Download Artifact Sources”，所有Maven公共仓库提供Source的jar包都可以下到源码，而且带注释。 Java Decomplier配置 下载反编译插件jd-eclipse-2.0.0（其他版本看这里） Eclipse安装（Help-&gt;Install New Software-&gt;Add，Archive选择“jd-eclipse-2.0.0.zip”） 安装完后重启Eclipse 如下图所示，打开Window-&gt;Preferences-&gt;Gneral-&gt;Editors-&gt;File Associations，选中“*.class without source”，在下方的Associated editors中选中“JD Class File Viewer”点击“Default-&gt;Apply and Close”。 点评*.class不用配置成JD，用原来的Class File Viewer就可以。反编译出来的毕竟不是源码，有可能行不对齐，所以会看到JD用注释标注的行号。还有反编译出来的并不一定准确，而且没注释。 建议换IDEA吧，IDEA自带反编译工具。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发工具</tag>
        <tag>eclipse</tag>
        <tag>源码</tag>
        <tag>jar</tag>
        <tag>decomplier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS添加用户]]></title>
    <url>%2F2019%2F07%2F29%2FCentOS%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[添加用户1useradd username 添加用户的同时将该用户指定到了同名的用户组中，如果将新添加的用户放到root组中，执行如下命令即可： 1useradd -g root username root是用户组名，username是用户名。 添加完用户要及时修改密码： 1passwd zengguang 密码输入两次。 切换用户： 1su username]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>useradd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-Singleton Pattern]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Singleton%2F</url>
    <content type="text"><![CDATA[线程安全四种线程安全的单例实现方式 饿汉式123456789101112131415161718192021222324252627282930/** * 饿汉式单例，在第一次加载类到内存时进行初始化（线程安全）。 * &lt;p&gt; * &lt;strong&gt;缺点：&lt;/strong&gt;非懒加载模式，在实例依赖参数或配置文件时无法使用。 * * @author zengguang * */public class StarveSingleton &#123; /** * 第一次类加载时创建实例。 */ private static final StarveSingleton INSTANCE = new StarveSingleton(); /** * 构造函数私有，不允许外部创建实例。 */ private StarveSingleton() &#123; &#125; /** * 直接返回类加载时创建的实例。 * * @return &#123;@link StarveSingleton&#125;的实例。 */ public static StarveSingleton getSingleton() &#123; return INSTANCE; &#125;&#125; 双检锁123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 双检锁单例模式（懒汉式，线程安全）。 * &lt;p&gt; * &lt;strong&gt;注意:&lt;/strong&gt;JDK1.5之前的版本volatile声明不一定起作用。 * * @author zengguang * @since JDK1.5 */public class DoubleCheckSingleton &#123; /** * 一定要有&lt;strong&gt;volatile&lt;/strong&gt;修饰，否则instance受指令重排的影响会返回一个空对象。 */ private volatile static DoubleCheckSingleton instance; /** * 构造函数私有，不允许外部创建实例。 */ private DoubleCheckSingleton() &#123; &#125; /** * 返回一个单例，当第一次调用时才创建一个实例。 * &lt;p&gt; * &lt;code&gt;instance = new DoubleCheckSingleton();&lt;/code&gt;并非源自操作，JVM中该行代码做了如下操作： * &lt;ol&gt; * &lt;li&gt;给instance分配内存&lt;/li&gt; * &lt;li&gt;调用&#123;@link DoubleCheckSingleton&#125;的构造函数来初始化成员变量&lt;/li&gt; * &lt;li&gt;将instance对象指向分配的内存空间&lt;/li&gt; * &lt;/ol&gt; * JVM在做指令重排时，并不能保证2/3步的顺序，顺序可能是1-2-3或者1-3-2，所以其他线程调用时可能&#123;@link DoubleCheckSingleton&#125;还没有初始化，进而出现NPE的问题。所以在instance变量声明需要加&#123;@code volatile&#125;修饰。 * * @return &#123;@link DoubleCheckSingleton&#125;的单实例。 */ public static DoubleCheckSingleton getSingleton() &#123; if (null == instance) &#123; synchronized (DoubleCheckSingleton.class) &#123; if (null == instance) &#123; instance = new DoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类123456789101112131415161718192021222324252627282930/** * 静态内部类单例（懒汉式，线程安全）。 * * @author zengguang * */public class NestedClassSingleton &#123; /** * 构造函数私有，不允许外部创建实例。 */ private NestedClassSingleton() &#123; &#125; /** * 静态内部类只有在第一次引用的时候才会被加载。 * * @return &#123;@link NestedClassSingleton&#125;的单实例。 */ public static NestedClassSingleton getSingleton() &#123; return SingletonHolder.INSTANCE; &#125; /** * 内部类，且为私有的，只有&#123;@link NestedClassSingleton&#125;本身才能访问。 */ private static class SingletonHolder &#123; private static final NestedClassSingleton INSTANCE = new NestedClassSingleton(); &#125;&#125; 枚举类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 枚举型单例模式（线程安全）。 * * @author zengguang * @since JDK1.5 */public class EnumSingleton &#123; /** * 构造函数私有，不允许外部创建实例。 */ private EnumSingleton() &#123; &#125; /** * * @return &#123;@link EnumSingleton&#125;的单实例 */ public static EnumSingleton getSingleton() &#123; return Singleton.INSTANCE.getSingleton(); &#125; /** * 这种实现方式有点类似静态内部类，而且枚举类型本质还是一个类。 */ private enum Singleton &#123; INSTANCE(new EnumSingleton()); private EnumSingleton isntance; /** * 外部类作为构造参数 * * @param singleton * 外部类 */ private Singleton(EnumSingleton singleton) &#123; this.isntance = singleton; &#125; /** * 枚举类型持有的单实例 * * @return &#123;@link EnumSingleton&#125;的单实例 */ private EnumSingleton getSingleton() &#123; return isntance; &#125; &#125;&#125; 参考资料 Java 利用枚举实现单例模式 Java实现单例模式（懒汉式、饿汉式、双重检验锁、静态内部类方式、枚举方式） 单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举 GitHub仓库SINGLETON]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>pattern</tag>
        <tag>singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-Builder Pattern]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%2F</url>
    <content type="text"><![CDATA[Builder Pattern：中文译名为“生成器模式”、“建造模式”。 示例假设一个对象Student： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student &#123; private int id; private String name; private int age; private String gender; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125;&#125; 初级编码不使用builder模式，我们创建一个实例并给实例赋值是这样的： 12345Student std = new Student();std.setId(10001);std.setAge(18);std.setName("小明");std.setGender("male"); 使用builder模式重新改造一下Student类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Student &#123; private int id; private String name; private int age; private String gender; public Student() &#123; &#125; public Student(int id, String name, int age, String gender) &#123; this.id = id; this.name = name; this.age = age; this.gender = gender; &#125; public static Student.StudentBuilder builder()&#123; return new StudentBuilder(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public static class StudentBuilder &#123; private int id; private String name; private int age; private String gender; public StudentBuilder id(int id) &#123; this.id = id; return this; &#125; public StudentBuilder name(String name) &#123; this.name = name; return this; &#125; public StudentBuilder age(int age) &#123; this.age = age; return this; &#125; public StudentBuilder gender(String gender) &#123; this.gender = gender; return this; &#125; public Student build() &#123; return new Student(this.id, this.name, this.age, this.gender); &#125; &#125;&#125; 使用builder模式后的画风是这个样子的： 1Student std = Student.builder().id(10001).age(18).name("小明").gender("male").build(); 从此再也不用先new一个实例然后挨个赋值啦，尤其对那些属性超级多的对象，或者创建实例时有些属性是可选的，写起来更是简洁。 改造builder模式要点 静态内部类 静态内部类属性设置方法与属性名相同（建议相同） 静态内部类属性设置方法返回内部类实例本身 内部静态类需要一个build()方法且返回类型为外部类 外部类需要实现一个全参数和无参构造函数 外部类需要一个静态builder()方法且返回类型为静态内部类 LombokLombok提供了@Builder声明式注解，直接可以让POJO拥有builder模式。 参考资料： 《Head First 设计模式》 org.elasticsearch.common.xcontent.XContentBuilder J-IM消息类org.jim.common.packets.Message及子类设计(v2.6.0) Lombok使用与原理 更新(2019/8/3)今天看到几篇Builder模式的博客，对之前的设计进行改进： 静态内部类 静态内部类属性设置方法与属性名相同（建议相同） 静态内部类属性设置方法返回内部类实例本身 内部静态类需要一个build()方法且返回类型为外部类 外部类需要实现一个全参数和无参构造函数 外部类需要一个入参为内部类的构造函数 外部类需要一个静态builder()方法且返回类型为静态内部类 改进1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class Student &#123; private int id; private String name; private int age; private String gender; public Student() &#123; &#125; public Student(Builder builder) &#123; this.id = builder.id; this.name = builder.name; this.age = builder.age; this.gender = builder.gender; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", age=" + age + ", gender=" + gender + "]"; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public static class Builder &#123; private int id; private String name; private int age; private String gender; public Builder id(int id) &#123; this.id = id; return this; &#125; public Builder name(String name) &#123; this.name = name; return this; &#125; public Builder age(int age) &#123; this.age = age; return this; &#125; public Builder gender(String gender) &#123; this.gender = gender; return this; &#125; public Student build() &#123; return new Student(this); &#125; &#125;&#125; 使用对比1234// 改进前Student std = Student.builder().id(10001).age(18).name("小明").gender("male").build();// 改进后Student std = new Student.Builder().id(10001).age(18).name("小明").gender("male").build(); 讨论当初想到用builder模式时，是在项目中有些javabean属性特别多，不想中规中矩的一行一行写setter方法。这里没有使用final修饰属性，说明这不是一个可变类，有一个public的无参构造函数，且所有的getter/setter方法都可访问，所以也可以看做是一个JavaBean。 参考资料 优雅地创建复杂对象 —— Builder 模式 设计模式之Builder模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>builder</tag>
        <tag>pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github上fork项目更新]]></title>
    <url>%2F2019%2F07%2F22%2FGithub%E4%B8%8Afork%E9%A1%B9%E7%9B%AE%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[场景：很早之前fork了github/gitee/gitlab等等的项目，但是项目经过多次迭代提交了更多更新，而自己账号下面被fork过来的项目并没有及时更新。此时，需要把提交过的内容更新到自己账号下的远程分支上。以我自己fork过的一个项目为例，主要分添加上游仓库和同步两个步骤。 添加上游仓库查看远程分支状态： 1git remote -v 添加需要同步的上游仓库： 1git remote add upstream https://github.com/tywo45/t-io 再次查看远程状态： 12345$ git remote -vorigin git@github.com:eEricZeng/t-io.git (fetch)origin git@github.com:eEricZeng/t-io.git (push)upstream https://github.com/tywo45/t-io (fetch)upstream https://github.com/tywo45/t-io (push) 同步将上游仓库内容拉到本地： 1git fetch upstream 此时，并没有将上游仓库的内容合并到本地中，可以使用status查看，也可以对比更新： 1git diff master upstream/master --stat 若要同步哪个分支就切换到对应的分支，例如master分支： 1git checkout master 同步并推送到自己账号下的远程分支，这里的同步本质是把upstream中master分支的内容合并到当前的master分支中： 12git merge upstream/mastergit push origin master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PicGo搭建Github图床]]></title>
    <url>%2F2019%2F07%2F20%2FPicGo%E6%90%AD%E5%BB%BAGithub%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[版本说明 node.js v6.4.1 PigGo v2.1.2 安装安装PicGo需要node.js环境，没有的看这里。下载PicGo最新版本安装包，根据操作系统下载相应的安装包，以Windows为例，在Assets中点击picgo-setup-2.1.2.exe下载。本地双机安装到指定的目录。安装完成如下图所示： GitHub图床PicGo支持SM.MS图床、腾讯云COS、微博图床、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云等各种图床。各家图床各有利弊，但是最好找一个稳定靠谱点的。虽然不是每一个都研究过，但是也是耳闻一些消息。像微博图床2019/4添加了防盗链，微博图床的老粉几多欢喜几多愁；CDN加速？薅羊毛还是要还的。个人独钟GitHub（主要是免费），当然哪天GitHub不能访问了就告别代码吧。 GitHub图床设置还是蛮简单的，PicGo官网配置说明。Windows点击右下角PicGo小图标打开软件，依次点击 图床设置-&gt;GitHub图床，需要配置的有以下三个必须参数： 仓库名 分支名 token 仓库名要带github用户名的，如我的配置：eEricZeng/imgbed。分支名无特殊需求使用master即可。token稍微麻烦一点，需要 登录GitHub-&gt;Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token，之后添加 Note 描述，勾选scopes中的repo（包含repo:status、repo_deployment、public_repo、repo:invite四项），点击 Generate token 生成token，复制到PicGo的token表单中，点击确定即可。返回到上传取即可体验PicGo。 更多更新 参考资料 PicGo官网 Markdown 图片粘贴工具 PicGo]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>PicGo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加阅读统计]]></title>
    <url>%2F2019%2F07%2F15%2Fhexo%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[版本说明 hexo v3.9.0 hexo-theme-next v7.1.2 不蒜子NexT内置了leancloud、firebase、busuanzi三种访客统计插件，前两种需要到官网注册获取网站颁发的appKey，相对麻烦，有兴趣的请访问leancloud、firebase。而不蒜子配置只需要将false改为true即可： 12busuanzi_count: enable: true 更多用法请参考官网说明不蒜子官网。 百度统计起初我以为阅读统计是通过百度统计进行计数的，后来发现百度统计、GA等只是分析工具，并不会把统计信息显示在博客页面上，所以是否需要百度统计看个人需求。打开百度统计，登录并进入网站列表，点击新增网站。以我的GitPage为例，填写新增网站表单，添加必要字段网站域名：eericzeng.github.io，网站首页：https://eericzeng.github.io， 网站名称 、行业类别选填。点击“确定”后，会出现包含如下信息的提示： 123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?324a1c41343d123482f031976f9"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; 复制”https://hm.baidu.com/hm.js?&quot; 后面的Id字符串，粘贴到主题配置文件中，如themes/next/_config.yml 12# Baidu Analytics IDbaidu_analytics: 324a1c41343d123482f031976f9 发布重新打包静态文件并发布： 12hexo ghexo s 点击百度统计控制台，代码管理-&gt;代码安装检查进行安装校验。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>阅读统计</tag>
        <tag>百度统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo站内搜索]]></title>
    <url>%2F2019%2F07%2F14%2Fhexo%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[版本说明 hexo v3.9.0 hexo-theme-next v7.1.2 安装插件安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 修改配置文件编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 执行如下命令进行本地展示： 12hexo ghexo s 参考next官方说明]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>search</tag>
        <tag>站内搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客站点sitemap的使用]]></title>
    <url>%2F2019%2F07%2F14%2Fhexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9sitemap%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[版本说明 hexo v3.9.0 hexo-theme-next v7.1.2 启用sitemap功能为了让博文被google或百度检索，需要使用hexo的sitemap功能。修改themes/next/_config.yml： 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 安装插件切换到hexo根目录下，安装搜索引擎插件，插件根据自己的需要安装其中一个或者都安装： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 如何此时你跟我一样使用的是next主题，直接执行如下命令即可访问站点地图： 1hexo g 此时，在public的静态文件根目录中会多出一个sitemap.xml文件，表示谷歌检索的sitemap安装成功。 谷歌检索检测网站是否被检索以GitHub Pages为例，新建的GitHub Pages是没有被谷歌检索的。在谷歌搜索栏中输入如下信息进行检索： 1site: xxx.github.io xxx为你的GitHub账号，如果没有被检索，不会显示hexo中的任何博文，如果有下面的步骤就可以省略了。 验证站点需要谷歌账号，没有的可以申请一个。登录GoogleSearchConsole，点击立即使用，输入需要验证所有权的网站地址，例如本站地址 1https://eericzeng.github.io 对于hexo博客网站，最好使用HTML标记法验证网站所有权，复制Google给的标记内容粘贴到themes/next/layout/_partials/head/head.swig文件meta标签最后面。这里使用的是next主题，其他主题类似。我发现next主题有更好的配置方式，千万不要采用修改head.swig文件的方法，不然在升级NexT版本时会遇到很多不必要的麻烦。修改themes/next/_config.yml文件： 123# Google Webmaster tools verification.# See: https://www.google.com/webmastersgoogle_site_verification: xxxxxxxxxx 然后生成静态文件并发布： 12hexo ghexo d 回到谷歌搜索控制台继续进行验证，点击完成。 添加sitemap.xml打开谷歌控制台选择上一步添加的网站-&gt;索引-&gt;站点地图，在添加新的站点地图中填入”sitemap.xml”即可，添加成功会在已提交的站点地图中显示，过一段时间在概述中会显示被索引的情况。 百度检索添加站点登录百度资源管理平台，依次点击用户中心-&gt;站点管理-&gt;添加网站（网站会随时更新，路径可能不同，只要找到添加网站的位置就可以）。 输入网址 12https//eericzeng.github.io//（注意协议头，gitpage在http基础上要加s） 站点属性最多可以选择三项，建议相关的都选上，提高曝光度 验证网站NexT主题选择HTML标签验证即可，复制标签中的content值，修改next配置文件_config.yml： 12345# Baidu Webmaster tools verification.# See: https://ziyuan.baidu.com/sitebaidu_site_verification: xxxxxxxxxx# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.baidu_push: true 百度资源页面先不要关闭，执行下面的步骤之后再点击完成验证。 发布并验证hexo根目录下执行如下命令： 12hexo ghexo d 回到百度资源网站，点击完成验证。 参考资料 让Google搜索到搭建在Github Pages上的博客 生成sitemap站点地图]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>sitemap</tag>
        <tag>检索</tag>
        <tag>搜索引擎</tag>
        <tag>google search</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客系统分类和标签的使用]]></title>
    <url>%2F2019%2F07%2F14%2Fhexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[版本说明 hexo v3.9.0 hexo-theme-next v7.1.2 写在前面以next主题为例，修改主题的配置文件themes/next/_config.yml，生效分类和标签： 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新创建的hexo博客没有分类和标签，点击分类或标签会提示”Cannot GET /categories/“和”Cannot GET /tags/“。 分类进入hexo博客所在的根目录，输入如下命令： 1hexo new page categories 成功后提示： 1INFO Created: HEXO_ROOT\source\categories\index.md index.md的内容如下： 1234---title: categoriesdate: 2019-07-14 17:51:10--- 这个index.md可以认为是存放分类的一个文档，只是type不同。修改为如下内容： 12345---title: 分类date: 2019-07-14 17:51:10type: "categories"--- 找到source/_posts路径下的markdown文章，并修改其categories属性。以hexo自带的hexo-world.md为例，文件头修改为： 12345---title: Hello Worlddate: 2019-06-28 22:36:00categories: hexo--- 此时，点击菜单栏中的“分类”，即可看到新建的“hexo”分类。 标签标签创建与分类类似，在控制台中输入如下命令： 12hexo new page tagsINFO Created: HEXO_ROOT\source\tags\index.md tags/index.md内容与分类类似，修改为如下内容： 12345---title: 标签date: 2019-07-14 18:19:31type: "tags"--- 同样在hello-world.md增加标签内容： 12345678---title: Hello Worlddate: 2019-06-28 22:36:00categories: hexotags: - hexo - others---]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tags</tag>
        <tag>categories</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用@Value读取.properties中文乱码及解决方法]]></title>
    <url>%2F2019%2F06%2F29%2FSpringBoot%E4%BD%BF%E7%94%A8%40Value%E8%AF%BB%E5%8F%96.properties%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题重现某不知名springboot小项目，application.properties文件： 1custom.param=中文属性值 java代码： 12345678910111213141516@SpringBootApplicationpublic class Application &#123; @Value("$&#123;custom.param&#125;") private String param; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Application.class, args); &#125; @PostConstruct public void printText() throws UnsupportedEncodingException &#123; System.out.println(param); System.out.println(new String(param.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8)); &#125;&#125; 控制台输出： 12ä¸­æå±æ§å¼中文属性值 结论先写结论：用@Value注解读取application.properties文件时，编码默认是ISO-8859-1，所以直接配置中文一定会乱码。注意，配置文件是springboot默认的配置文件application.properties或application-{active}.properties。其他配置文件会在原因分析中进行详解，原因分析涉及大量源码解读，如果不想烧脑深入分析的话可以直接跳到解决方案一节。 写在前面写本文时，我查了网上几乎所有关于@Value读取.properties中文乱码的文章。一种思路是修改编码格式；另外一种是利用插件/IDE将中文预先编码，在注入到变量后直接转码为所需要的中文。遇到中文乱码修改编码方式是常规思路，所以第一种思路看似没问题，但是把springboot所有关于encoding的配置参数修改为UTF-8后，中文乱码的问题依然没有解决。 原因分析 Spring Boot版本：2.1.1.RELEASE application.properties采用ISO-8859-1加载 自定义test.properties可以设置编码格式 .yml/.yaml默认采用UTF-8加载 application.properties文件加载正如前文所述读取配置文件时，编码出现了问题。追踪一下spring boot是加载默认配置文件的过程，会发现org.springframework.boot.contex.config.ConfigFileApplicationListener类的loadDocuments()方法，源码如下： 12345678910private List&lt;Document&gt; loadDocuments(PropertySourceLoader loader, String name, Resource resource) throws IOException &#123; DocumentsCacheKey cacheKey = new DocumentsCacheKey(loader, resource); List&lt;Document&gt; documents = this.loadDocumentsCache.get(cacheKey); if (documents == null) &#123; List&lt;PropertySource&lt;?&gt;&gt; loaded = loader.load(name, resource); documents = asDocuments(loaded); this.loadDocumentsCache.put(cacheKey, documents); &#125; return documents;&#125; 入参loader的类型是PropertySourceLoader，PropertySourceLoader是加载属性文件的接口，其实现有两个类：PropertiesPropertySourceLoader和YamlPropertySourceLoader。loader根据传入参数的实例调用load()方法，此处我们讨论.properties文件，接口声明和properties加载实现如下： 12345678910111213141516171819202122232425262728293031323334/*********属性文件加载接口**********/public interface PropertySourceLoader &#123; String[] getFileExtensions(); List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException;&#125;/*********properties文件加载实现**********/public class PropertiesPropertySourceLoader implements PropertySourceLoader &#123; private static final String XML_FILE_EXTENSION = ".xml"; @Override public String[] getFileExtensions() &#123; return new String[] &#123; "properties", "xml" &#125;; &#125; @Override public List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException &#123; Map&lt;String, ?&gt; properties = loadProperties(resource); if (properties.isEmpty()) &#123; return Collections.emptyList(); &#125; return Collections.singletonList(new OriginTrackedMapPropertySource(name, properties)); &#125; @SuppressWarnings(&#123; "unchecked", "rawtypes" &#125;) private Map&lt;String, ?&gt; loadProperties(Resource resource) throws IOException &#123; String filename = resource.getFilename(); if (filename != null &amp;&amp; filename.endsWith(XML_FILE_EXTENSION)) &#123; return (Map) PropertiesLoaderUtils.loadProperties(resource); &#125; return new OriginTrackedPropertiesLoader(resource).load(); &#125;&#125; 通过源码分析PropertiesPropertySourceLoader并不单纯的加载.properties文件，还包含.xml文件（似乎有违单一功能原则，不知道当初这样设计的初衷是啥）。顺着load()方法向下找-&gt;loadProperties(Resource)-&gt;OriginTrackedPropertiesLoader.load()-&gt;OriginTrackedPropertiesLoader.load(boolean)-&gt;OriginTrackedPropertiesLoader$CharacterReader(Resource)。CharacterReader是OriginTrackedPropertiesLoader的内部静态类，而且只有一个构造函数，看看器构造参数就不难发现为啥application.properties是以ISO-8859-1编码加载的了： 12345678private static class CharacterReader implements Closeable &#123; // 其他代码省略 CharacterReader(Resource resource) throws IOException &#123; this.reader = new LineNumberReader(new InputStreamReader( resource.getInputStream(), StandardCharsets.ISO_8859_1)); &#125; // 其他代码省略&#125; 也就是说不论application.properties文件被设置为哪种编码格式，最终还是以ISO-8859-1的编码格式进行加载。 yml/yaml默认以UTF-8加载让我们再看看yml/yaml格式的文件，其加载由PropertySourceLoader接口的另外一个实例YamlPropertySourceLoader实现，即接口方法load()： 1List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException; 追一下load()的底层实现，采用org.yaml.snakeyaml.reader.UnicodeReader的实例对yml/ymal文件进行加载，而UnicodeReader实例对文件的初始化方法init()实现如下： 1234567891011121314151617181920212223242526272829303132protected void init() throws IOException &#123; if (internalIn2 != null) return; Charset encoding; byte bom[] = new byte[BOM_SIZE]; int n, unread; n = internalIn.read(bom, 0, bom.length); if ((bom[0] == (byte) 0xEF) &amp;&amp; (bom[1] == (byte) 0xBB) &amp;&amp; (bom[2] == (byte) 0xBF)) &#123; encoding = UTF8; unread = n - 3; &#125; else if ((bom[0] == (byte) 0xFE) &amp;&amp; (bom[1] == (byte) 0xFF)) &#123; encoding = UTF16BE; unread = n - 2; &#125; else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE)) &#123; encoding = UTF16LE; unread = n - 2; &#125; else &#123; // Unicode BOM mark not found, unread all bytes encoding = UTF8; unread = n; &#125; if (unread &gt; 0) internalIn.unread(bom, (n - unread), unread); // Use given encoding CharsetDecoder decoder = encoding.newDecoder().onUnmappableCharacter( CodingErrorAction.REPORT); internalIn2 = new InputStreamReader(internalIn, decoder);&#125; 每次调用read()读文件时都会调用init()方法进行初始化，也就是这个时候确定文件的编码格式。首先读取BOM（Byte Order Mark）文件头信息，如果头信息中有UTF8/UTF16BE/UTF16LE就采用对应的编码，没有或者不是则采用UTF8编码。 自定义test.properties文件编码采用@PropertySource(value=”classpath:test.properties”, encoding=”UTF-8”)方式读取配置文件可按照UTF-8的方式读取编码，而不是ISO-8859-1。@PropertySource配置的加载文件由ConfigurationClassParser.processPropertySource()进行解析，EncodedResource类决定最后由哪种编码格式加载文件，其方法如下： 1234567891011public Reader getReader() throws IOException &#123; if (this.charset != null) &#123; return new InputStreamReader(this.resource.getInputStream(), this.charset); &#125; else if (this.encoding != null) &#123; return new InputStreamReader(this.resource.getInputStream(), this.encoding); &#125; else &#123; return new InputStreamReader(this.resource.getInputStream()); &#125; &#125; 所以，虽然都是.properties文件，但是编码格式却是不一样的。 解决方案 自定义配置文件 使用yml/yaml配置文件 IDE/插件预编码 自定义配置文件通过@PropertySource(value=”classpath:my.properties”, encoding=”UTF-8”)注解配置自定义文件，注意文件名不能是springboot默认的application.properties文件名称。 使用yml/yaml配置文件将yml/yaml文件设置为UTF-8的编码格式，springboot读该文件即采用UTF-8编码。 IDE/插件预编码采用编译器或者插件将配置文件预编码。这种方法我没试过，但是想想也知道这是很反人类的。如果有人感兴趣的话，可以参考一下这篇博客最后一部分IDEA/eclipse的修改操作。 总结在配置application.properties时，都是开发比较重要的参数，尽量使用英文，业务相关的中文配置还是不要放到这里。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
        <tag>@Value</tag>
        <tag>properties</tag>
        <tag>utf-8</tag>
        <tag>编码</tag>
        <tag>乱码</tag>
        <tag>yaml</tag>
        <tag>yml</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[联系方式： QQ：549373335 网易：zengguang05@163.com Gmail：zengguang05@gmail.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
